<project name="Charts">

	<variable name="copyright"><![CDATA[/*******************************************************************************
 * Copyright 2015 Thomson Reuters
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/]]></variable>
	<variable name="autogenNote">/* NOTE: This file is autogenerated, do not edit this file directly.*/</variable>
	<variable name="cppNamespace">Charts</variable>
	<variable name="javaPackage">com.thomsonreuters.corptech.charts</variable>
	<variable name="objcClassPrefix">TR</variable>
	<variable name="jniCppNamespace">TRChartsJNI</variable>
	<variable name="objcSupportNamespace">TRChartsObjc</variable>
	<variable name="cppPublicFilePrefix">TRCharts/</variable>
	<variable name="cppPrivateFilePrefix">TRCharts/Impl/</variable>
	<variable name="jniCppFilePrefix">TRChartsJNI/</variable>
	<variable name="objcFilePrefix">TRChartsObjc/</variable>
	<variable name="objcTestFilePrefix">TRChartsObjcTests/</variable>

	<output type="java" targetDir="TRChartsJava/src/com/thomsonreuters/corptech/charts"/>
	<output type="jni" targetDir="TRChartsJava/jni/TRChartsJNI/TRChartsJNI"/>
	<output type="objc" targetDir="TRChartsObjc/TRChartsObjc"/>
	<output type="cpp" targetDir="TRCharts/TRCharts"/>
	<output type="impl" targetDir="TRCharts/TRCharts/Impl" overwrite="false"/>
	<output type="objctest" targetDir="TRChartsObjc/TRChartsObjcTests"/>
	<output type="objctestimpl" targetDir="TRChartsObjc/TRChartsObjcTests/Impl" overwrite="true"/>

	<enum name="Edge">
		<comment>Represents the chart edge where an axis is drawn.</comment>
		<value name="left">
			<comment>Place axis on the left</comment>
		</value>
		<value name="right">
			<comment>Place axis on the right</comment>
		</value>
		<value name="bottom">
			<comment>Place axis on the bottom</comment>
		</value>
		<value name="top">
			<comment>Place axis on the top</comment>
		</value>
	</enum>

	<enum name="FontHint">
		<comment>Font rendering hints.</comment>
		<value name="accurate">
			<comment>Draw the font as accurately as possible (potentially sacrifice speed)</comment>
		</value>
		<value name="fast">
			<comment>Draw the font as quickly as possible (potentially sacrifice accuracy)</comment>
		</value>
	</enum>

	<enum name="LogLevel">
		<comment>Log level, each log level implies that level, and all more severe levels</comment>
		<value name="trace">
			<comment>Log everything</comment>
		</value>
		<value name="debug">
			<comment>Log internal developer information</comment>
		</value>
		<value name="info">
			<comment>Log general information</comment>
		</value>
		<value name="warn">
			<comment>Log minor/recoverable errors and incorrect usage</comment>
		</value>
		<value name="error">
			<comment>Log serious errors</comment>
		</value>
	</enum>

	<enum name="LineMode">
		<comment>Line style mode.</comment>
		<value name="solid">
			<comment>Draw a solid line</comment>
		</value>
		<value name="dashed">
			<comment>Draw a dashed line</comment>
		</value>
	</enum>

	<enum name="DateUnit">
		<comment>Unit for date calcualations and display</comment>
		<value name="second">
			<comment>Seconds</comment>
		</value>
		<value name="minute">
			<comment>Minutes</comment>
		</value>
		<value name="hour">
			<comment>Hours</comment>
		</value>
		<value name="day">
			<comment>Days</comment>
		</value>
		<value name="month">
			<comment>Months</comment>
		</value>
		<value name="year">
			<comment>Years</comment>
		</value>
	</enum>

	<enum name="ResizeMode">
		<comment>Controls what happens when the chart area is resized.</comment>
		<value name="rescale">
			<comment>Increase the scale, so that the same data is displayed.</comment>
		</value>
		<value name="relayout">
			<comment>Layout the data again.</comment>
		</value>
		<value name="preserve">
			<comment>Do not affect the scale or layout.</comment>
		</value>
	</enum>

	<enum name="FormatSyntax">
		<comment>Formating mode (for dates/numbers)</comment>
		<value name="cstdlib">
			<comment>Use C standard library methods (default locale)</comment>
		</value>
		<value name="platform">
			<comment>Use platform methods (platform default locale)</comment>
		</value>
	</enum>

	<field name="logLevel" type="LogLevel" description="log level" defaultValue="trace">
		<comment>Library-wide log level setting</comment>
	</field>

	<field name="logHandler" type="LogHandler" description="log target">
		<comment>Library-wide log handler.</comment>
		<comment>Log messages will only be delivered to the handler if the log level exceeds the library-wide log level.</comment>
		<comment>If not set, logging will be handled in a platform-specific way.</comment>
	</field>

	<field name="debugGLValidationEnabled" type="Boolean" description="OpenGL validation setting" defaultValue="false">
		<comment>Library-wide debug OpenGL validation setting</comment>
	</field>

	<interface name="LogHandler">
		<comment>Callback interface for logging</comment>
		<method name="logMessage" returnType="Void">
			<comment>Handle a log mesage</comment>
			<parameter name="level" type="LogLevel">
				<comment>The log level</comment>
			</parameter>
			<parameter name="message" type="String">
				<comment>The log message</comment>
			</parameter>
		</method>
	</interface>

	<struct name="Font">
		<comment>Represents a font</comment>
		<comment>Resolving the name to a usable font is platform-dependent.</comment>
		<comment scope="objc">The font is looked up using CTFontCreateWithName or equivalent</comment>
		<comment scope="java">The font is looked up using com.thomsonreuters.corptech.tr3dutils.TextFactory</comment>
		<field name="name" type="String" description="font name"/>
		<field name="size" type="Integer" description="font size">
			<comment>Size of the font, in platform specific units (more detail?)</comment>
		</field>
		<field name="hint" type="FontHint" description="font rendering hint">
			<comment>This value is currently ignored.</comment>
		</field>
	</struct>

	<struct name="Color">
		<comment>Represents an RGBA color (values range between 0-255)</comment>
		<field name="red" type="Number" description="red component"/>
		<field name="green" type="Number" description="green component"/>
		<field name="blue" type="Number" description="blue component"/>
		<field name="alpha" type="Number" description="alpha component"/>
	</struct>

	<struct name="LineStyle">
		<comment>Represents a line style</comment>
		<field name="thickness" type="Number" description="line thickness"/>
		<field name="mode" type="LineMode" description="line mode"/>
	</struct>

	<struct name="PointStyle">
		<comment>Represents a point style</comment>
		<field name="diameter" type="Number" description="point diameter"/>
	</struct>

	<struct name="IndexRange">
		<comment>Represents an integer start and end index (start:inclusive, end:exclusive)</comment>
		<comment>A valid index range must be ordered such that min is less than or equal to max. Most methods (except valid and positive) expect that the supplied index range is valid and will
			likely return unexpected results if this is not the case.</comment>
		<field name="begin" type="Integer" description="start of range">
			<comment>The start of range is inclusive</comment>
		</field>
		<field name="end" type="Integer" description="end of range">
			<comment>The end of range is exclusive</comment>
		</field>
		<method name="length" instance="false" returnType="Integer">
			<comment>Length of the range (in.end - in.begin)</comment>
			<parameter name="indexRange" type="IndexRange">
				<comment>Input range (in)</comment>
			</parameter>
		</method>
		<method name="valid" instance="false" returnType="Boolean">
			<comment>If true, the parameter index range is ordered such that in.begin &lt;= in.end (i.e. the length may be 0)</comment>
			<parameter name="indexRange" type="IndexRange">
				<comment>Input range (in)</comment>
			</parameter>
		</method>
		<method name="validWithin" instance="false" returnType="Boolean">
			<comment>If true, the parameter index range is valid, and it does not exceed the extents of the withinRange parameter (in.begin &gt;= within.begin &amp;&amp; in.end &lt;= within.end)</comment>
			<parameter name="indexRange" type="IndexRange">
				<comment>Input range (in)</comment>
			</parameter>
			<parameter name="otherIndexRange" type="IndexRange">
				<comment>Within range (within)</comment>
			</parameter>
		</method>
		<method name="positive" instance="false" returnType="Boolean">
			<comment>If true, the parameter index range is ordered such that in.begin &lt; in.end</comment>
			<parameter name="indexRange" type="IndexRange">
				<comment>Input range (in)</comment>
			</parameter>
		</method>
		<method name="merge" instance="false" returnType="IndexRange">
			<comment>Returns the smallest range enclosing both supplied ranges min(a.begin, b.begin), max(a.end, b.end)</comment>
			<parameter name="indexRange" type="IndexRange">
				<comment>Input range (a)</comment>
			</parameter>
			<parameter name="otherIndexRange" type="IndexRange">
				<comment>Input range (b)</comment>
			</parameter>
		</method>
		<method name="clamp" instance="false" returnType="IndexRange">
			<comment>Constrain the parameter index range such that it does not exceed the extents of the withinRange parameter (in.begin &gt;= within.begin &amp;&amp; in.end &lt;= within.end)</comment>
			<parameter name="indexRange" type="IndexRange">
				<comment>Input range (in)</comment>
			</parameter>
			<parameter name="withinIndexRange" type="IndexRange">
				<comment>Within range (within)</comment>
			</parameter>
		</method>
		<method name="overlap" instance="false" returnType="Boolean">
			<comment>Returns true if the ranges intersect (but not if they just touch) i.e returns true iff max(a.begin, b.begin) &lt;= min(a.end, b.end)</comment>
			<parameter name="indexRange" type="IndexRange">
				<comment>Input range (a)</comment>
			</parameter>
			<parameter name="otherIndexRange" type="IndexRange">
				<comment>Input range (b)</comment>
			</parameter>
		</method>
	</struct>

	<struct name="Margin">
		<comment>Represents 4 edges (for margin/padding/etc)</comment>
		<field name="left" type="Number" description="left margin"/>
		<field name="right" type="Number" description="right margin"/>
		<field name="bottom" type="Number" description="bottom margin"/>
		<field name="top" type="Number" description="top margin"/>
		<method name="add" instance="false" returnType="Margin">
			<comment>Utility method to add two margins (edgewise)</comment>
			<comment>Return value is (result.left = first.left + second.left, ...)</comment>
			<parameter name="margin" type="Margin">
				<comment>First margin</comment>
			</parameter>
			<parameter name="toMargin" type="Margin">
				<comment>Second margin</comment>
			</parameter>
		</method>
	</struct>

	<struct name="Point">
		<comment>Represents a 2D point. (Used as a conceptual point and vector).</comment>
		<field name="x" type="Number" description="X value"/>
		<field name="y" type="Number" description="Y value"/>
		<method name="add" returnType="Point" instance="false">
			<comment>Utility method to add two points (componentwise)</comment>
			<comment>Return value is (result.x = first.x + second.x, ...)</comment>
			<parameter name="point" type="Point">
				<comment>First point</comment>
			</parameter>
			<parameter name="otherPoint" type="Point">
				<comment>Second point</comment>
			</parameter>
		</method>
		<method name="subtract" returnType="Point" instance="false">
			<comment>Utility method to subtract two points (componentwise)</comment>
			<comment>Return value is (result.x = first.x - second.x, ...)</comment>
			<parameter name="point" type="Point">
				<comment>First point</comment>
			</parameter>
			<parameter name="otherPoint" type="Point">
				<comment>Second point</comment>
			</parameter>
		</method>
		<method name="multiply" returnType="Point" instance="false">
			<comment>Utility method to multiply two points (componentwise)</comment>
			<comment>Return value is (result.x = first.x * second.x, ...)</comment>
			<parameter name="point" type="Point">
				<comment>First point</comment>
			</parameter>
			<parameter name="otherPoint" type="Point">
				<comment>Second point</comment>
			</parameter>
		</method>
		<method name="divide" returnType="Point" instance="false">
			<comment>Utility method to divide two points (componentwise)</comment>
			<comment>Return value is (result.x = first.x / second.x, ...)</comment>
			<parameter name="point" type="Point">
				<comment>First point</comment>
			</parameter>
			<parameter name="otherPoint" type="Point">
				<comment>Second point</comment>
			</parameter>
		</method>
	</struct>

	<struct name="Size">
		<comment>Represents a 2D size.</comment>
		<field name="width" type="Number" description="X dimension"/>
		<field name="height" type="Number" description="Y dimension"/>
	</struct>

	<struct name="Coordinates">
		<comment>Represents a data point (independent of datum type).</comment>
		<field name="abscissa" type="Number" description="abscsissa value"/>
		<field name="ordinate" type="Number" description="ordinate value"/>
	</struct>

	<struct name="ContinuousDatum">
		<comment>Continuous datums have two co-ordinates, an abscissa (usually X) and an ordinate (usually Y), although X and Y can be flipped
		using axis association. In a continuous datum the abscissa value is always a real number, and the ordinate type is defined by subclasses.
		Ordinate values may be complex (structured), or numbers. The interpretation of a datum is series-dependent, a given continuous series
		implementation will always require a specific datum type.
		</comment>
		<field name="abscissa" type="Number" description="abscissa value">
			<comment>The independent variable (usually)</comment>
		</field>
	</struct>

	<struct name="ScalarDatum" extend="ContinuousDatum">
		<comment>A continuous datum holding scalar (number) values</comment>
		<field name="ordinate" type="Number" description="ordinate value">
			<comment>The dependent variable (usually)</comment>
		</field>
	</struct>

	<struct name="Range">
		<comment>An inclusive range in the real number domain.</comment>
		<field name="min" type="Number" description="min value"/>
		<field name="max" type="Number" description="max value"/>
		<method name="length" instance="false" returnType="Number">
			<comment>Return the length of the range (max - min)</comment>
			<parameter name="range" type="Range">
				<comment>Input range</comment>
			</parameter>
		</method>
		<method name="valid" instance="false" returnType="Boolean">
			<comment>Returns true if the min value is less than or equal to max value</comment>
			<parameter name="range" type="Range">
				<comment>Input range</comment>
			</parameter>
		</method>
		<method name="positive" instance="false" returnType="Boolean">
			<comment>Returns true if the min value is less than max value</comment>
			<parameter name="range" type="Range">
				<comment>Input range</comment>
			</parameter>
		</method>
		<method name="merge" instance="false" returnType="Range">
			<comment>Returns the enclosing range of the arguments</comment>
			<comment>Both ranges must be valid, else behaviour is not defined.</comment>
			<parameter name="range" type="Range">
				<comment>Input range</comment>
			</parameter>
			<parameter name="otherRange" type="Range">
				<comment>Input range</comment>
			</parameter>
		</method>
		<method name="clamp" instance="false" returnType="Range">
			<comment>Clamps the input range so that it's min and max values fall within the clamp range.</comment>
			<comment>Both ranges must be valid, else behaviour is not defined.</comment>
			<parameter name="range" type="Range">
				<comment>Input range</comment>
			</parameter>
			<parameter name="withinRange" type="Range">
				<comment>Clamp range</comment>
			</parameter>
		</method>
		<method name="overlap" instance="false" returnType="Boolean">
			<comment>Returns true if the ranges overlap (intersect)</comment>
			<comment>Both ranges must be valid, else behaviour is not defined.</comment>
			<parameter name="range" type="Range">
				<comment>Input range</comment>
			</parameter>
			<parameter name="otherRange" type="Range">
				<comment>Input range</comment>
			</parameter>
		</method>
		<method name="identity" instance="false" returnType="Range">
			<comment>Returns the range [0,0]</comment>
		</method>
	</struct>

	<struct name="RangeDatum" extend="ContinuousDatum">
		<comment>A continuous datum holding range values.</comment>
		<field name="ordinate" type="Range" description="ordinate value">
			<comment>The dependent variable (usually)</comment>
		</field>
	</struct>

	<struct name="OHLC">
		<comment>An open/high/low/close value.</comment>
		<field name="open" type="Number" description="open value"/>
		<field name="high" type="Number" description="high value"/>
		<field name="low" type="Number" description="low value"/>
		<field name="close" type="Number" description="close value"/>
	</struct>

	<struct name="OHLCDatum" extend="ContinuousDatum">
		<comment>A continuous datum holding open/high/low/close values.</comment>
		<field name="ordinate" type="OHLC" description="ordinate value">
			<comment>The dependent variable (usually)</comment>
		</field>
	</struct>

	<class name="Attachable" concrete="false">
		<comment>Base class for all objects that can be attached to each other (eg a series can be attached to a chart)</comment>
		<comment>Each attachable object may be attached to at most one other object, the relationship is conceptually such that a child object is aware that it
			is attached to a parent object. The management of the relationship happens at the native layer, and due to some implementation-specific weirdness
			around the joining of host ref-counting/gc with native memory management, it is not possible to safely retrieve the reference to the parent from the child.</comment>
		<comment>It is an error to attempt to attach one object to multiple parents. This error may occur when (for example) a series is added to two charts.
			The error is realised as a host-language exception (exception type not specified).</comment>
		<field name="attached" type="Boolean" readonly="true" description="attachment state">
			<comment>True if this object is attached to a aprent</comment>
		</field>
		<field name="enabled" type="Boolean" description="enabled flag" defaultValue="true">
			<comment>If true, this object should have no effect on its parent (visual or otherwise)</comment>
		</field>
	</class>

	<class name="Drawable" extend="Attachable" concrete="false">
		<comment>Base class for all objects that can be drawn</comment>
		<field name="visible" type="Boolean" description="visibility flag" defaultValue="true">
			<comment>If false, the object will not be drawn (but it may have a visual or interactive effect on surrounding objects)</comment>
		</field>
		<field name="opacity" type="Number" description="opacity (0-255)" defaultValue="255">
			<comment>Overall opacity of this object. This is mixed (multiplied) with the alpha of any relevant colour value within the drawable object.</comment>
		</field>
	</class>

	<class name="ChartElement" extend="Drawable" concrete="false">
		<comment>Base class for all objects that can be attached to a chart</comment>
		<field name="drawOrder" type="Integer" description="draw order">
			<comment>Can be used to control z-ordering (higher values are drawn on top of lower values).</comment>
		</field>
	</class>

	<class name="Label" extend="Drawable">
		<comment>Combines a text value and its visual style.</comment>
		<field name="text" type="String" description="label text"/>
		<field name="color" type="Color" description="label color"/>
		<field name="font" type="Font" description="label font"/>
		<field name="margin" type="Margin" description="label margin">
			<comment>Per-edge margin (can be used to offset the label from its draw area)</comment>
		</field>
		<field name="size" type="Size" description="label size">
			<comment>Size of the label in points, must be specified explicitly for correct layout</comment>
			<comment type="warning">It was intended that a facility should be provided to automatically infer this
				from the font size and text content, but this was never implemented. As such, it is necessary to estimate
				(or externally calculate) the point size of the label.</comment>
		</field>
	</class>

	<interface name="NumberFormatter">
		<comment>Callback interface for number formatting</comment>
		<method name="formatNumber" returnType="String">
			<comment>Should implement to return a formatted number</comment>
			<parameter name="value" type="Number">
				<comment>Number to format</comment>
			</parameter>
		</method>
	</interface>

	<class name="BasicNumberFormatter" implement="NumberFormatter">
		<comment>Format a number using a set number of decimal spaces (using the platform current locale)</comment>
		<field name="decimalPlaces" type="Integer" defaultValue="3" description="number of decimal places to display"/>
		<method name="formatNumber" returnType="String">
			<comment>Returns the formatted number</comment>
			<parameter name="value" type="Number">
				<comment>Number to format</comment>
			</parameter>
		</method>
	</class>

	<class name="SuffixNumberFormatter" extend="BasicNumberFormatter">
		<comment>Extends BasicNumberFormatter, to also display the relevant metric suffix (by default)</comment>
		<comment>The formatter is configurable, and could be used with other bases and suffixes; the first suffix will be used for a magnitude that exceeds base^0, the second for a magnitude that exceeds base^1, and so on.</comment>
		<field name="base" type="Integer" defaultValue="1000">
			<comment>Indicates the threshold base for selecting a suffix.</comment>
		</field>
		<field name="suffixes" type="List[String]" defaultValue=",K,M,G,T,P,E,Z,Y">
			<comment>Suffix for magnitudes that exceed each power of the base.</comment>
		</field>
		<method name="formatNumber" returnType="String">
			<comment>Returns the formatted number</comment>
			<parameter name="value" type="Number">
				<comment>Number to format</comment>
			</parameter>
		</method>
	</class>

	<interface name="DateFormatter">
		<comment>Formatter for dates</comment>
		<method name="formatDate" returnType="String">
			<comment>Format a date</comment>
			<parameter name="seconds" type="Number">
				<comment>Seconds since midnight 1 Jan 1970 (unix stamp). Non-integer (subsecond) times are explicitly supported by the API, but may not be supported by all implementations.</comment>
			</parameter>
			<parameter name="unit" type="DateUnit">
				<comment>Unit hint, this is provided when formatting dates at a given tick interval, so the formatter can display different ranges of dates with varying precision.</comment>
			</parameter>
		</method>
	</interface>

	<class name="AbstractDateFormatter" implement="DateFormatter" concrete="false">
		<comment>Format a date using either the platform formatting mechanism or c-standard library mechanism (dependent on syntax property)</comment>
		<field name="syntax" type="FormatSyntax" defaultValue="cstdlib" description="formatting mode">
			<comment>Specifies whether the platform data formatting mechanism or c-standard library mechanism should be used.</comment>
		</field>
		<method name="formatDate" returnType="String">
			<comment>Format a date</comment>
			<parameter name="seconds" type="Number">
				<comment>Date value (in seconds)</comment>
			</parameter>
			<parameter name="unit" type="DateUnit">
				<comment>Unit hint.</comment>
			</parameter>
		</method>
	</class>

	<class name="BasicDateFormatter" extend="AbstractDateFormatter">
		<comment>Format a date (see AbstractDateFormatter)</comment>
		<field name="format" type="String">
			<comment>Format string (in either platform format or c-standard library format, depending on syntax parameter)</comment>
		</field>
	</class>

	<class name="PerUnitDateFormatter" extend="AbstractDateFormatter">
		<comment>Format a date differently for the closest unit.</comment>
		<method name="setUnitFormat" returnType="Void" mutating="true">
			<comment>Set the per-unit format string</comment>
			<parameter name="unit" type="DateUnit">
				<comment>Relevant unit</comment>
			</parameter>
			<parameter name="format" type="String">
				<comment>Format string (in either platform format or c-standard library format, depending on syntax parameter)</comment>
			</parameter>
		</method>
		<method name="getUnitFormat" returnType="String">
			<comment>Get the per-unit format string (returns the empty string if no format set for this unit)</comment>
			<parameter name="unit" type="DateUnit">
				<comment>Relevant unit</comment>
			</parameter>
		</method>
		<method name="setZeroUnitFormat" returnType="Void" mutating="true">
			<comment>Set the per-unit-zero format string (used when values below the unit are zero)</comment>
			<parameter name="unit" type="DateUnit">
				<comment>Relevant unit</comment>
			</parameter>
			<parameter name="format" type="String">
				<comment>Format string (in either platform format or c-standard library format, depending on syntax parameter)</comment>
			</parameter>
		</method>
		<method name="getZeroUnitFormat" returnType="String">
			<comment>Get the per-unit-zero format string (returns the empty string if no format set for this unit)</comment>
			<parameter name="unit" type="DateUnit">
				<comment>Relevant unit</comment>
			</parameter>
		</method>
	</class>

	<interface name="NumberTickCalculator">
		<comment>Callback interface for calculating the tick interval for a number axis</comment>
		<method name="calculateTickInterval" returnType="Number">
			<comment>Should return the data-space number interval between ticks</comment>
			<parameter name="dataRange" type="Range">
				<comment>Total data range for the axis</comment>
			</parameter>
			<parameter name="visibleDataRange" type="Range">
				<comment>Data range that is visible under the current data transform</comment>
			</parameter>
			<parameter name="screenLength" type="Number">
				<comment>Visual length of the axis on the screen (in points)</comment>
			</parameter>
		</method>
	</interface>

	<class name="FixedNumberTickCalculator" implement="NumberTickCalculator">
		<comment>Number tick calculator implementation that returns a constant pre-specified tick interval</comment>
		<field name="tickInterval" type="Number" defaultValue="1.0" description="tick interval">
			<comment>This value is always returned by calculateTickInterval</comment>
		</field>
		<method name="calculateTickInterval" returnType="Number">
			<comment>Returns the value of tickInterval</comment>
			<parameter name="dataRange" type="Range">
				<comment>Ignored</comment>
			</parameter>
			<parameter name="visibleDataRange" type="Range">
				<comment>Ignored</comment>
			</parameter>
			<parameter name="screenLength" type="Number">
				<comment>Ignored</comment>
			</parameter>
		</method>
	</class>

	<class name="AutomaticNumberTickCalculator" implement="NumberTickCalculator">
		<comment>Calculates a number tick interval based on a target screen-space interval.</comment>
		<field name="targetScreenInterval" type="Number" defaultValue="1.0" description="target screen-space interval (hint)"/>
		<field name="minInterval" type="Number" description="minimum interval"/>
		<field name="base" type="Number" defaultValue="10.0"/>
		<field name="multipliers" type="List[Number]" defaultValue="5.0, 2.0">
			<comment>Use [5, 2] for static automatic multi-axis tick alignment (more docs needed)</comment>
		</field>
		<method name="calculateTickInterval" returnType="Number">
			<comment>Returns the calculated number tick interval</comment>
			<parameter name="dataRange" type="Range">
				<comment>Total data range for the axis</comment>
			</parameter>
			<parameter name="visibleDataRange" type="Range">
				<comment>Data range that is visible under the current data transform</comment>
			</parameter>
			<parameter name="screenLength" type="Number">
				<comment>Visual length of the axis on the screen (in points)</comment>
			</parameter>
		</method>
	</class>

	<struct name="DateInterval">
		<comment>Combines a date unit and magnitude</comment>
		<field name="unit" type="DateUnit" description="date unit"/>
		<field name="magnitude" type="Number" description="unit magnitude"/>
	</struct>

	<interface name="DateTickCalculator">
		<comment>Callback interface for calculating the tick interval for a date axis</comment>
		<method name="calculateTickInterval" returnType="DateInterval">
			<comment>Should return the date interval between ticks</comment>
			<parameter name="dataRange" type="Range">
				<comment>Total data range for the axis</comment>
			</parameter>
			<parameter name="visibleDataRange" type="Range">
				<comment>Data range that is visible under the current data transform</comment>
			</parameter>
			<parameter name="screenLength" type="Number">
				<comment>Visual length of the axis on the screen (in points)</comment>
			</parameter>
		</method>
	</interface>

	<class name="FixedDateTickCalculator" implement="DateTickCalculator">
		<comment>Date tick calculator implementation that returns a constant pre-specified tick interval</comment>
		<field name="tickInterval" type="DateInterval" defaultValue="second,1.0">
			<comment>This value is always returned by calculateTickInterval</comment>
		</field>
		<method name="calculateTickInterval" returnType="DateInterval">
			<comment>Returns the value of tickInterval</comment>
			<parameter name="dataRange" type="Range">
				<comment>Ignored</comment>
			</parameter>
			<parameter name="visibleDataRange" type="Range">
				<comment>Ignored</comment>
			</parameter>
			<parameter name="screenLength" type="Number">
				<comment>Ignored</comment>
			</parameter>
		</method>
	</class>

	<class name="AutomaticDateTickCalculator" implement="DateTickCalculator">
		<field name="targetScreenInterval" type="Number" defaultValue="1.0"/>
		<field name="minInterval" type="DateInterval"/>
		<method name="calculateTickInterval" returnType="DateInterval">
			<comment>Returns the calculated date tick interval</comment>
			<parameter name="dataRange" type="Range">
				<comment>Total data range for the axis</comment>
			</parameter>
			<parameter name="visibleDataRange" type="Range">
				<comment>Data range that is visible under the current data transform</comment>
			</parameter>
			<parameter name="screenLength" type="Number">
				<comment>Visual length of the axis on the screen (in points)</comment>
			</parameter>
		</method>
	</class>

	<interface name="RangeCalculator">
		<comment>A range calculator is used to define the default range of a data series. It is axis-specific.</comment>
		<comment>The calculateRange method takes a parameter, initially this is the actual min..max data range of all series associated with the axis, the
		method should return a new data range. All built-in implementations of RangeCalculator (except FixedRangeCalculator) have a rangeCalculator parameter,
		which can be used to allow chaining, that is the supplied range calculator is called and then the calculateRange method called with that result.</comment>
		<method name="calculateRange" returnType="Range">
			<comment>Calculate the output data range</comment>
			<parameter name="dataRange" type="Range">
				<comment>Input data range</comment>
			</parameter>
		</method>
	</interface>

	<class name="FixedRangeCalculator" implement="RangeCalculator">
		<comment>A range calculator that always returns a fixed range.</comment>
		<field name="range" type="Range" description="fixed range"/>
		<method name="calculateRange" returnType="Range">
			<comment>The output data range is always the same as the value supplied in the range field</comment>
			<parameter name="dataRange" type="Range">
				<comment>Input data range</comment>
			</parameter>
		</method>
	</class>

	<class name="IncludeZeroRangeCalculator">
		<comment>A range calculator that expands the supplied range such that it always includes the value 0.</comment>
		<field name="rangeCalculator" type="RangeCalculator">
			<comment>Optional input range calculator (if specified, this is called first and the result used as the input to calculateRange)</comment>
		</field>
		<method name="calculateRange" returnType="Range">
			<comment>The output data range is the enclosing range of [in.min...in.max] and [0]</comment>
			<parameter name="dataRange" type="Range">
				<comment>Input data range</comment>
			</parameter>
		</method>
	</class>

	<class name="PaddingRangeCalculator" implement="RangeCalculator">
		<comment>A range calculator that expands the supplied range in both directions by a padding value (must be specified in data coordinates).</comment>
		<field name="rangeCalculator" type="RangeCalculator">
			<comment>Optional input range calculator (if specified, this is called first and the result used as the input to calculateRange)</comment>
		</field>
		<field name="padding" type="Range">
			<comment>Padding (expressed in data coordinates)</comment>
		</field>
		<method name="calculateRange" returnType="Range">
			<comment>The output data range is [in.min-padding...in.max+padding]</comment>
			<parameter name="dataRange" type="Range">
				<comment>Input data range</comment>
			</parameter>
		</method>
	</class>

	<!-- should rename -->
	<class name="TickAligningRangeCalculator" implement="RangeCalculator">
		<comment>If this range calculator is used with the AutomaticNumberTickCalculator, it will produce a range that can be automatically aligned
		(that is, it will be aligned to a power of 2 and 5)</comment>
		<comment>NOTE: This will only currently work properly for positive ranges (where in.min and in.max are greater than or equal 0), it will also clamp the
		minimum value of the range to zero. The support for non-positive ranges is buggy and has been disabled.</comment>
		<field name="rangeCalculator" type="RangeCalculator">
			<comment>Optional input range calculator (if specified, this is called first and the result used as the input to calculateRange)</comment>
		</field>
		<method name="calculateRange" returnType="Range">
			<comment>The output data range is [0...align(in.max)], where align(x) returns the next highest power of 2 or 5 to x</comment>
			<parameter name="dataRange" type="Range">
				<comment>Input data range</comment>
			</parameter>
		</method>
	</class>

	<struct name="DataTransform">
		<comment>A data-space transformation; could be visualized as a transform matrix (but without a rotation component)</comment>
		<field name="offset" type="Number" description="offset (data space)"/>
		<field name="scale" type="Number" description="scale (data space)" defaultValue="1.0"/>
		<method name="concatenate" instance="false" returnType="DataTransform">
			<comment>Return the concatenated (multiplied) space transform</comment>
			<parameter name="dataTransform" type="DataTransform">
				<comment>Input transform</comment>
			</parameter>
			<parameter name="otherDataTransform" type="DataTransform">
				<comment>Input transform</comment>
			</parameter>
		</method>
		<method name="invert" instance="false" returnType="DataTransform">
			<comment>Return the transform that yields the identity when concatenated to the parameter transform</comment>
			<parameter name="dataTransform" type="DataTransform">
				<comment>Input transform</comment>
			</parameter>
		</method>
		<method name="apply" instance="false" returnType="Number">
			<comment>Transform a scalar into the provided space</comment>
			<parameter name="dataTransform" type="DataTransform">
				<comment>Input transform</comment>
			</parameter>
			<parameter name="value" type="Number">
				<comment>Input value</comment>
			</parameter>
		</method>
		<method name="applyRange" instance="false" returnType="Range">
			<comment>Transform a range into the provided space</comment>
			<parameter name="dataTransform" type="DataTransform">
				<comment>Input transform</comment>
			</parameter>
			<parameter name="range" type="Range">
				<comment>Input value</comment>
			</parameter>
		</method>
		<method name="unapply" instance="false" returnType="Number">
			<comment>Transform a scalar out of the provided space (i.e. into the inverse of the space)</comment>
			<parameter name="dataTransform" type="DataTransform">
				<comment>Input transform</comment>
			</parameter>
			<parameter name="value" type="Number">
				<comment>Input value</comment>
			</parameter>
		</method>
		<method name="unapplyRange" instance="false" returnType="Range">
			<comment>Transform a range out of the provided space (i.e. into the inverse of the space)</comment>
			<parameter name="dataTransform" type="DataTransform">
				<comment>Input transform</comment>
			</parameter>
			<parameter name="range" type="Range">
				<comment>Input range</comment>
			</parameter>
		</method>
	</struct>

	<interface name="AxisLayout">
		<comment>An axis layout is used to calculate the default data transform for an axis. It is provided with the enclosing
		range (min, max) of all series in the axis (assuming that all series use the same units).</comment>
		<method name="calculateTransform" returnType="DataTransform">
			<comment>Calculate layout transform for the axis</comment>
			<parameter name="axis" type="ContinuousAxis">
				<comment>Axis requiring layout</comment>
			</parameter>
			<parameter name="dataRange" type="Range">
				<comment>Data range for all series associated with the axis</comment>
			</parameter>
			<parameter name="screenLength" type="Number">
				<comment>Length of the axis, in screen co-ordinates</comment>
			</parameter>
			<parameter name="renderTransform" type="DataTransform">
				<comment>Current offset transform (i.e. transform caused by panning and zooming).</comment>
			</parameter>
		</method>
	</interface>

	<class name="DataFittingAxisLayout" implement="AxisLayout">
		<comment>An axis layout that tries to fit all available data into the visible area.</comment>
		<field name="rangeCalculator" type="RangeCalculator">
			<comment>Assigning a range calculator is optional, if not supplied, the data range supplied by the axis will be used.</comment>
		</field>
		<method name="calculateTransform" returnType="DataTransform">
			<comment>Calculate layout transform for the axis</comment>
			<parameter name="axis" type="ContinuousAxis">
				<comment>Axis requiring layout</comment>
			</parameter>
			<parameter name="dataRange" type="Range">
				<comment>Data range for all series associated with the axis</comment>
			</parameter>
			<parameter name="screenLength" type="Number">
				<comment>Length of the axis, in screen co-ordinates</comment>
			</parameter>
			<parameter name="renderTransform" type="DataTransform">
				<comment>Current offset transform (i.e. transform caused by panning and zooming).</comment>
			</parameter>
		</method>
	</class>

	<class name="Axis" extend="ChartElement" concrete="false">
		<comment>Base axis class, see concrete implementations for more details</comment>
		<comment>A chart can hae a number of axes, each is assigned a given edge. If a chart has multiple axes on a given edge, they will be stacked.</comment>
		<comment>This base class provides configuration for the generalized display of an axis. An axis has a primary line (drawn on the selected edge),
		gridlines (drawn inside the data area and perpendicular to the edge) and ticks (drawn on the outside of the data area and perpendicular to the edge).</comment>
		<comment type="warning">It is important to always set the tickLabelMaxSize field for an axis, the maximum size is not calculated based on the text width</comment>
		<field name="edge" type="Edge" description="axis edge">
			<comment>Defines which edge of the chart the axis is placed on</comment>
		</field>
		<field name="title" type="Label" description="axis title">
			<comment>Text label displayed on the axis, the orientation and display of the label is based on the edge</comment>
		</field>
		<field name="axisColor" type="Color" description="axis color">
			<comment>Color for the label and main line of the axis</comment>
		</field>
		<field name="axisLineStyle" type="LineStyle" description="axis line style" defaultValue="1.0,solid">
			<comment>The line style used for the main line of the axis</comment>
		</field>
		<field name="gridVisible" type="Boolean" description="grid visibility flag">
			<comment>If true, a grid will be drawn perpendicular to the axis, at the tick frequency</comment>
		</field>
		<field name="gridColor" type="Color" description="grid color">
			<comment>Color for the grid lines (if enabled)</comment>
		</field>
		<field name="gridLineStyle" type="LineStyle" description="grid line style" defaultValue="1.0,solid">
			<comment>Line style for the grid lines (if enabled)</comment>
		</field>
		<field name="tickColor" type="Color" description="tick color">
			<comment>Color used for tick marks and labels</comment>
		</field>
		<field name="tickLineStyle" type="LineStyle" description="tick line style" defaultValue="1.0,solid">
			<comment>Line style used for the tick marks</comment>
		</field>
		<field name="tickOffset" type="Number" description="tick offset">
			<comment>Point offset of the ticks relative to the edge (positive number moves the tick away from the edge)</comment>
		</field>
		<field name="tickSize" type="Number" description="tick size">
		</field>
		<field name="tickLabelColor" type="Color" description="tick label color">
			<comment>Color used for the tick label</comment>
		</field>
		<field name="tickLabelFont" type="Font" description="tick label font">
			<comment>Font used for the tick label</comment>
		</field>
		<field name="tickLabelMaxSize" type="Number" description="tick label maximum size">
			<comment>Maximum size of the tick label (must be specified size it influences the chart layout)</comment>
		</field>
		<field name="tickLabelOffset" type="Number" description="tick label offset">
			<comment>Offset of the label from the tick mark (positive number moves the label away from the tick mark)</comment>
		</field>
		<field name="screenLength" type="Number" readonly="true" description="current screen length">
			<comment>Read-only property that indicates the total calculated screen length of the axis (perpendicular to edge)</comment>
		</field>
		<method name="relayout" returnType="Void" mutating="true">
			<comment>Call to cause the axis to be laid out again on the next update call</comment>
		</method>
	</class>

	<class name="ContinuousAxis" extend="Axis" concrete="false">
		<comment>A continuous axis </comment>
		<field name="layout" type="AxisLayout" description="axis layout"/>
		<field name="rangeCalculator" type="RangeCalculator" description="range calculator"/>
		<field name="valueTransform" type="DataTransform" description="value transform" defaultValue="0.0, 1.0"/>
		<field name="dataRange" type="Range" readonly="true"/>
		<field name="screenDataRange" type="Range" readonly="true"/>
	</class>

	<class name="AbstractNumberAxis" extend="ContinuousAxis" concrete="false">
		<comment>Base class for axes that display numbers</comment>
		<field name="tickFormatter" type="NumberFormatter" description="tick formatter"/>
	</class>

	<class name="NumberAxis" extend="AbstractNumberAxis">
		<comment>An axis that displays uniformly spaced (linear) number ticks.</comment>
		<field name="tickCalculator" type="NumberTickCalculator" description="tick calculator"/>
		<field name="tickInterval" type="Number" readonly="true" description="tick interval"/>
	</class>

	<class name="DateAxis" extend="ContinuousAxis">
		<comment>An axis that displays date ticks.</comment>
		<field name="offsetSeconds" type="Number" description="offset from UTC"/>
		<field name="tickFormatter" type="DateFormatter" description="tick formatter"/>
		<field name="tickCalculator" type="DateTickCalculator" description="tick calculator"/>
		<field name="tickInterval" type="DateInterval" readonly="true" description="tick interval"/>
	</class>

	<class name="CategoryAxis" extend="Axis">
		<comment>An axis for displaying categories, eg for bar charts (not currently implemented/used)</comment>
	</class>

	<class name="Series" extend="ChartElement" concrete="false">
		<field name="ordinateAxis" type="ContinuousAxis" description="ordinate axis">
			<comment>The ordinate axis is conventionally used to plot the dependent variable.</comment>
		</field>
		<field name="color" type="Color">
			<comment>Base color for the visual representation of the series.</comment>
		</field>
		<method name="markDirty" returnType="Void" mutating="true">
			<comment>Mark the whole data range as dirty.</comment>
		</method>
		<method name="markRangeDirty" returnType="Void" mutating="true">
			<comment>Mark a range of datums as dirty (requiring reload in next update/draw).</comment>
			<parameter name="range" type="IndexRange">
				<comment>Data source range to mark</comment>
			</parameter>
		</method>
	</class>

	<templateClass name="ContinuousSeries" extend="Series" concrete="false">
		<templateParameter name="T"/>
		<field name="abscissaAxis" type="ContinuousAxis" description="abscissa axis">
			<comment>The abscissa axis is conventionally used to plot the independent variable.</comment>
		</field>
		<field name="dataSource" type="ContinuousDataSource[T]" description="data source"/>
		<field name="colorSource" type="ColorSource" description="color source">
			<comment>The color source is used to provide a different color for each datum.</comment>
		</field>
		<method name="screenPositionToValue" returnType="Coordinates">
			<comment>Get the data value for the given screen position</comment>
			<parameter name="screenPosition" type="Point">
				<comment>Screen position.</comment>
			</parameter>
		</method>
		<method name="valueToScreenPosition" returnType="Point">
			<comment>Get the screen position for the given data value</comment>
			<parameter name="value" type="Coordinates">
				<comment>Data-space co-ordinates.</comment>
			</parameter>
		</method>
		<method name="getDatum" returnType="T">
			<comment>Get the datum with the provided index.</comment>
			<parameter name="index" type="Integer">
				<comment>Data source index</comment>
			</parameter>
		</method>
		<method name="interpolateDatum" returnType="T">
			<comment>Interpolate the datum value at the provided abscissa value.</comment>
			<comment>The interpolated value is dependent on the series type.</comment>
			<parameter name="abscissa" type="Number">
				<comment>Abscissa value</comment>
			</parameter>
		</method>
		<method name="getIndexBeforeAbscissaValue" returnType="Integer">
			<comment>Get the datum index that appears before the provided abscissa value.</comment>
			<comment>Distance is calculated in data space.</comment>
			<comment>Returns -1 if there is no datum available.</comment>
			<parameter name="abscissa" type="Number">
				<comment>Abscissa value</comment>
			</parameter>
			<parameter name="includeEqual" type="Boolean">
				<comment>If true, the last datum with an exactly equal abscissa value will be returned, if such a datum exists.</comment>
			</parameter>
		</method>
		<method name="getIndexAfterAbscissaValue" returnType="Integer">
			<comment>Get the datum index that appears after the provided abscissa value.</comment>
			<comment>Distance is calculated in data space.</comment>
			<comment>Returns -1 if there is no datum available.</comment>
			<parameter name="abscissa" type="Number">
				<comment>Abscissa value</comment>
			</parameter>
			<parameter name="includeEqual" type="Boolean">
				<comment>If true, the first datum with an exactly equal abscissa value will be returned, if such a datum exists.</comment>
			</parameter>
		</method>
		<method name="getIndexNearestAbscissaValue" returnType="Integer">
			<comment>Get the datum index that appears nearest the provided abscissa value.</comment>
			<comment>Distance is calculated in data space.</comment>
			<comment>Returns -1 if there is no datum available.</comment>
			<parameter name="abscissa" type="Number">
				<comment>Abscissa value</comment>
			</parameter>
		</method>
		<method name="getIndexNearestScreenPosition" returnType="Integer">
			<comment>Get the datum index that appears nearest the provided screen position.</comment>
			<comment>Distance is calculated in screen space.</comment>
			<comment>Returns -1 if there is no datum available.</comment>
			<parameter name="screenPosition" type="Point">
				<comment>Screen position.</comment>
			</parameter>
		</method>
		<method name="getDatumSquaredDistanceToScreenPosition" returnType="Number">
			<comment>Get the squared distance between the provided screen position and the datum at the provided index.</comment>
			<comment>Distance is calculated in screen space.</comment>
			<parameter name="index" type="Integer">
				<comment>Data source index</comment>
			</parameter>
			<parameter name="screenPosition" type="Point">
				<comment>Screen position.</comment>
			</parameter>
		</method>
		<method name="getOrdinateRangeWithinAbscissaRange" returnType="Range">
			<comment>Return the range (min-max) of the ordinate (dependent) variable, in a given abscissa (independent) range.</comment>
			<comment>This method operates in data co-ordinates.</comment>
			<parameter name="abscissaRange" type="Range">
				<comment>Abscissa range (data co-ordinates).</comment>
			</parameter>
		</method>
	</templateClass>

	<class name="PointSeries" extend="ContinuousSeries[ScalarDatum]">
		<comment>A series that displays scalar datums as disconnected points.</comment>
		<field name="pointStyle" type="PointStyle" defaultValue="1.0">
			<comment>The point style</comment>
		</field>
	</class>

	<class name="LineSeries" extend="ContinuousSeries[ScalarDatum]">
		<comment>A series that displays scalar datums as a line.</comment>
		<field name="lineStyle" type="LineStyle" defaultValue="1.0, solid" description="line style">
			<comment>The line style (may be overridden by values derived using the lineStyleSource)</comment>
		</field>
		<field name="lineStyleSource" type="LineStyleSource" description="line style source">
			<comment>May optionally be provided, to control the per-datum line style.</comment>
			<comment type="see">LineStyleSource</comment>
		</field>
	</class>

	<class name="SteppedLineSeries" extend="LineSeries">
		<comment>A series that displays scalar datums as a stepped line.</comment>
	</class>

	<class name="BandSeries" extend="ContinuousSeries[RangeDatum]">
		<comment>A series that displays range datums as a band.</comment>
	</class>

	<class name="SteppedBandSeries" extend="BandSeries">
		<comment>A series that displays range datums as a stepped band.</comment>
	</class>

	<class name="AreaSeries" extend="ContinuousSeries[ScalarDatum]">
		<comment>A series that displays the area under scalar datums.</comment>
	</class>

	<class name="SteppedAreaSeries" extend="AreaSeries">
		<comment>A series that displays the stepped area under scalar datums.</comment>
	</class>

	<class name="CandlestickSeries" extend="ContinuousSeries[OHLCDatum]">
		<comment>A series that displays OHLC datums as candlesticks.</comment>
		<comment type="warning">This class is not implemented graphically, it is included to ensure that the API could support this type of chart, but was never needed.</comment>
	</class>

	<templateInterface name="ContinuousDataSource">
		<templateParameter name="T"/>
		<method name="getDatumRange" returnType="IndexRange">
			<comment>Return the currently available range of datums</comment>
			<parameter name="series" type="ContinuousSeries[T]">
				<comment>The series instance currently using the datasource (the data source may be shared between series)</comment>
			</parameter>
		</method>
		<method name="getDatums" returnType="List[T]">
			<comment>Get a range of datums</comment>
			<comment>Returning more/less datums than requested is explicitly supported, provided the returned range starts from the correct index.</comment>
			<parameter name="series" type="ContinuousSeries[T]">
				<comment>The series instance currently using the datasource (the data source may be shared between series)</comment>
			</parameter>
			<parameter name="range" type="IndexRange">
				<comment>Requested index range.</comment>
			</parameter>
		</method>
	</templateInterface>

	<interface name="ColorSource">
		<comment>Provides a means to override the color source for each displayed datum.</comment>
		<method name="getColors" returnType="List[Color]">
			<comment>Override to return the datum colors for the requested range</comment>
			<parameter name="series" type="Series">
				<comment>Requesting series.</comment>
			</parameter>
			<parameter name="range" type="IndexRange">
				<comment>Requested index range.</comment>
			</parameter>
			<parameter name="defaultColor" type="Color">
				<comment>Base color</comment>
			</parameter>
		</method>
	</interface>

	<interface name="LineStyleSource">
		<comment>Provides a means to override the line style for each displayed datum.</comment>
		<method name="getLineStyles" returnType="List[LineStyle]">
			<comment>Override to return the datum line styles for the requested range</comment>
			<parameter name="series" type="Series">
				<comment>Requesting series.</comment>
			</parameter>
			<parameter name="range" type="IndexRange">
				<comment>Requested index range.</comment>
			</parameter>
			<parameter name="defaultLineStyle" type="LineStyle">
				<comment>Base line style</comment>
			</parameter>
		</method>
	</interface>

	<class name="Decoration" extend="ChartElement" concrete="false">
		<comment>Base class for a chart decoration</comment>
		<field name="color" type="Color">
			<comment>Base color (assumed to be applicable to all decorations)</comment>
		</field>
	</class>

	<class name="LineDecoration" extend="Decoration">
		<comment>Draws a line at a fixed data position on a given axis</comment>
		<field name="axis" type="ContinuousAxis">
			<comment>Axis to associate the decoration with. The decoration will intersect the axis at the specified value</comment>
		</field>
		<field name="value" type="Number">
			<comment>Position in data co-ordinates (relative to the axis)</comment>
		</field>
		<field name="lineStyle" type="LineStyle" defaultValue="1.0, solid">
			<comment>Drawing style for the line</comment>
		</field>
	</class>

	<class name="PointDecoration" extend="Decoration">
		<comment>Draws a point at a fixed data position on a given pair of axes</comment>
		<field name="abscissaAxis" type="ContinuousAxis" description="abscissa axis">
			<comment>The abscissa (traditionally X) axis</comment>
		</field>
		<field name="ordinateAxis" type="ContinuousAxis" description="ordinate axis">
			<comment>The ordinate (traditionally Y) axis</comment>
		</field>
		<field name="value" type="Coordinates">
			<comment>Position in data co-ordinates</comment>
		</field>
		<field name="pointStyle" type="PointStyle" defaultValue="1.0">
			<comment>Drawing style for the point</comment>
		</field>
	</class>

	<class name="Animation" extend="Attachable">
		<comment>An animation describes a series of effects that are applied over a duration.</comment>
		<comment>To animate elements, create effects targetting those elements and associate them with an animation, then add the animation to a chart.</comment>
		<comment>The animation will run until completion, then the (optional) animation delegate will be called, and the animation will be removed from the
			chart in the next update cycle.</comment>
		<field name="duration" type="Number" defaultValue="1">
			<comment>Animation duration (in seconds)</comment>
		</field>
		<field name="position" type="Number" defaultValue="0">
			<comment>Current position of the animation (in seconds)</comment>
		</field>
		<field name="effectList" type="List[AnimationEffect]" description="effect list">
			<comment>Effects applied by this animation</comment>
		</field>
		<field name="delegate" type="AnimationDelegate">
			<comment>The delegate will be called back when the animation is completed (or cancelled)</comment>
		</field>
		<method name="restart" returnType="Void" mutating="true">
			<comment>Set animation position to beginning and continue running.</comment>
		</method>
		<method name="complete" returnType="Void" mutating="true">
			<comment>Set animation position to the end and stop running, flag the animation for removal.</comment>
		</method>
		<method name="cancel" returnType="Void" mutating="true">
			<comment>Stop running, flag the animation for removal.</comment>
		</method>
	</class>

	<interface name="AnimationDelegate">
		<comment>Delegate for animation events</comment>
		<method name="animationCompleted" returnType="Void">
			<comment>Called when the animation is completed.</comment>
			<parameter name="animation" type="Animation">
				<comment>The animation that has completed.</comment>
			</parameter>
		</method>
		<method name="animationCancelled" returnType="Void">
			<comment>Called when the animation is cancelled.</comment>
			<parameter name="animation" type="Animation">
				<comment>The animation that has been cancelled.</comment>
			</parameter>
		</method>
	</interface>

	<interface name="AnimationEffect">
		<comment>Callback interface/protocol for an animation effect.</comment>
		<method name="apply" returnType="Void" concrete="false" mutating="false">
			<comment>Apply the next step of the animation.</comment>
			<parameter name="position" type="Number">
				<comment>Position of the animation (in seconds)</comment>
			</parameter>
			<parameter name="duration" type="Number">
				<comment>Duration of the animation (in seconds)</comment>
			</parameter>
		</method>
	</interface>

	<class name="FadeInEffect" implement="AnimationEffect">
		<comment>Fade the targeted drawables into view (opacity from 0% to 100%)</comment>
		<field name="drawableList" type="List[Drawable]">
			<comment>Targeted drawables</comment>
		</field>
		<method name="apply" returnType="Void" mutating="false">
			<comment>Apply the next step of the animation.</comment>
			<parameter name="position" type="Number">
				<comment>Position of the animation (in seconds)</comment>
			</parameter>
			<parameter name="duration" type="Number">
				<comment>Duration of the animation (in seconds)</comment>
			</parameter>
		</method>
	</class>

	<class name="FadeOutEffect" implement="AnimationEffect">
		<comment>Fade the targeted drawables out of view (opacity from 100% to 0%)</comment>
		<field name="drawableList" type="List[Drawable]">
			<comment>Targeted drawables</comment>
		</field>
		<method name="apply" returnType="Void" mutating="false">
			<comment>Apply the next step of the animation.</comment>
			<parameter name="position" type="Number">
				<comment>Position of the animation (in seconds)</comment>
			</parameter>
			<parameter name="duration" type="Number">
				<comment>Duration of the animation (in seconds)</comment>
			</parameter>
		</method>
	</class>

	<interface name="Renderable">
		<comment>Base interface/protocol for objects with a visual representation</comment>
		<method name="resize" returnType="Void" mutating="true">
			<comment>Set the render area size (nothing will be drawn outside this area).</comment>
			<comment scope="objc">In iOS, a content scale factor is used to help with specifying Retina/non-Retina sizes. The content scale factor should be
				supplied to the chart (the size value itself should not be pre-multiplied by the scale factor). On non-iOS platforms the default value of 1.0 can be used.</comment>
			<comment scope="java">This content scale factor value is for iOS Retina use, it can be set to 1.0 for all other environments.</comment>
			<parameter name="size" type="Size">
				<comment>Size of the area in points</comment>
			</parameter>
			<parameter name="contentScaleFactor" type="Number">
				<comment>Content scale factor (iOS specific)</comment>
			</parameter>
		</method>
		<method name="preUpdate" returnType="Void" mutating="true">
			<comment>Load new data</comment>
			<comment>Calling this method is optional</comment>
		</method>
		<method name="update" returnType="Boolean" mutating="true">
			<comment>Synchronize changed properties with internal state</comment>
			<comment>A valid size must be set before calling this method</comment>
		</method>
		<method name="preRender" returnType="Void">
			<comment>Prepare OpenGL context for rendering</comment>
			<comment>Must be called from a thread which has the correct OpenGL context.</comment>
			<comment>Calling this method is optional</comment>
		</method>
		<method name="render" returnType="Void">
			<comment>Must be called from a thread which has the correct OpenGL context.</comment>
		</method>
		<method name="dispose" returnType="Void" mutating="true">
			<comment>Must be called from a thread which has the correct OpenGL context.</comment>
		</method>
	</interface>

	<struct name="Transform">
		<comment>A screen-space transform</comment>
		<field name="offset" type="Point" description="offset" defaultValue="0.0, 0.0"/>
		<field name="scale" type="Point" description="scale" defaultValue="1.0, 1.0"/>
		<method name="concatenate" instance="false" returnType="Transform">
			<comment>Concatenate (multiply) two transforms</comment>
			<parameter name="transform" type="Transform">
				<comment>First transform</comment>
			</parameter>
			<parameter name="otherTransform" type="Transform">
				<comment>Second transform</comment>
			</parameter>
		</method>
	</struct>

	<class name="Constraint" extend="Attachable">
		<comment>Allows a constraint behaviour to be attached to a chart.</comment>
		<comment>This approach is used because Attachable is a native-implemented class, but the behaviour needs to be a host-provided callback.</comment>
		<field name="behaviour" type="ConstraintBehaviour"/>
	</class>

	<interface name="ConstraintBehaviour">
		<comment>Provides the ability to adjust the charts transform after any movement event.</comment>
		<comment>The apply method is called during the update phase, whenever a movement is detected and before any attached objects are updated.</comment>
		<method name="apply" returnType="Transform" mutating="false">
			<comment>Called whenever the chart's transform is changed externally, the actual transform will be overwriten with the return value.</comment>
			<parameter name="chart" type="Chart">
				<comment>Current chart</comment>
			</parameter>
			<parameter name="size" type="Size">
				<comment>Screen-space size of the chart</comment>
			</parameter>
			<parameter name="transform" type="Transform">
				<comment>Screen-space transform</comment>
			</parameter>
		</method>
	</interface>

	<class name="DataScaleConstraintBehaviour" implement="ConstraintBehaviour">
		<comment>Constrain the data scale for a given set of axes, such that the axis cannot be zoomed out further than the total data range.</comment>
		<field name="axes" type="List[Axis]">
			<comment>Axes to target</comment>
		</field>
		<method name="apply" returnType="Transform" mutating="false">
			<cmment>Calculate the scale constraint transform.</cmment>
			<parameter name="chart" type="Chart">
				<comment>Current chart</comment>
			</parameter>
			<parameter name="size" type="Size">
				<comment>Screen-space size of the chart</comment>
			</parameter>
			<parameter name="transform" type="Transform">
				<comment>Screen-space transform</comment>
			</parameter>
		</method>
	</class>

	<class name="DataOffsetConstraintBehaviour" implement="ConstraintBehaviour">
		<comment>Constrain the data scale for a given set of axes, such that the axis cannot be panned further than the total data range.</comment>
		<field name="axes" type="List[Axis]">
			<comment>Axes to target</comment>
		</field>
		<field name="edges" type="List[Edge]" defaultValue="left,right,bottom,top">
			<comment>Edges to target</comment>
		</field>
		<field name="multiplier" type="Number" defaultValue="1">
			<comment>Mix factor between the current value and the fully constrained value (may be used to visually animate the constraint).</comment>
		</field>
		<method name="apply" returnType="Transform" mutating="false">
			<cmment>Calculate the offset constraint transform.</cmment>
			<parameter name="chart" type="Chart">
				<comment>Current chart</comment>
			</parameter>
			<parameter name="size" type="Size">
				<comment>Screen-space size of the chart</comment>
			</parameter>
			<parameter name="transform" type="Transform">
				<comment>Screen-space transform</comment>
			</parameter>
		</method>
	</class>

	<class name="Chart" extend="Drawable" implement="Renderable">
		<comment>Root container for all chart objects.</comment>
		<field name="title" type="Label" description="chart title">
			<comment>The title is displayed above the chart. It is optional.</comment>
		</field>
        <field name="backgroundColor" type="Color" description="background color">
			<comment>The background color is used to paint the chart container.</comment>
		</field>
		<field name="fillColor" type="Color" description="area color">
			<comment>The fill color is used to paint the area within the chart's axes.</comment>
		</field>
		<field name="margin" type="Margin" description="margin">
			<comment>The margin is the empty space around the chart.</comment>
		</field>
		<field name="axisList" type="List[Axis]" readonly="true" description="axis list">
			<comment>The axis list contains all currently associated axes.</comment>
		</field>
		<field name="seriesList" type="List[Series]" readonly="true" description="series list">
			<comment>The series list contains all currently associated series.</comment>
		</field>
		<field name="decorationList" type="List[Decoration]" readonly="true" description="decoration list">
			<comment>The series list contains all currently associated decorations.</comment>
		</field>
		<field name="constraintList" type="List[Constraint]" readonly="true" description="constraint list">
			<comment>The series list contains all currently associated constraints.</comment>
		</field>
		<field name="activeAnimationList" type="List[Animation]" readonly="true" description="active animation list">
			<comment>The active animation list contains all attached animations.</comment>
		</field>
		<field name="lastTouches" type="List[Touch]" readonly="true" description="latest touch list"/>
		<field name="size" type="Size" readonly="true">
			<comment>Size of the render area in points (actual pixel render area is multiplied by the content scale factor)</comment>
		</field>
		<field name="contentScaleFactor" type="Number" description="content scale factor" defaultValue="1.0" readonly="true">
			<comment>Content scale factor (iOS specific)</comment>
		</field>
		<field name="resizeMode" type="ResizeMode" description="resize mode"/>
		<field name="transform" type="Transform" description="current transform" returnReference="false"/>
		<method name="resize" returnType="Void" mutating="true">
			<comment>Set the render area size (nothing will be drawn outside this area).</comment>
			<comment>In iOS, a content scale factor is used to help with specifying Retina/non-Retina sizes. The content scale factor should be
				supplied to the chart (the size value itself should not be pre-multiplied by the scale factor). On non-iOS platforms the default value of 1.0 can be used.</comment>
			<parameter name="size" type="Size">
				<comment>Size of the area in points</comment>
			</parameter>
			<parameter name="contentScaleFactor" type="Number">
				<comment>Content scale factor (iOS specific)</comment>
			</parameter>
		</method>
		<method name="relayout" returnType="Void" mutating="true">
			<comment>Mark the chart as needing layout recalculation. The recalculation happens during the next update phase.</comment>
		</method>
		<method name="addAxis" returnType="Void" mutating="true">
			<comment>Adds an axis to the chart.</comment>
			<comment>The axis will be attached to this chart, until removeAxis is called or the chart is destroyed.</comment>
			<comment type="see">Attachable</comment>
			<parameter name="axis" type="Axis">
				<comment>The axis to add.</comment>
			</parameter>
		</method>
		<method name="addSeries" returnType="Void" mutating="true">
			<comment>Adds a series to the chart.</comment>
			<comment>The series will be attached to this chart, until removeSeries is called or the chart is destroyed.</comment>
			<comment type="see">Attachable</comment>
			<parameter name="series" type="Series">
				<comment>The series to add.</comment>
			</parameter>
		</method>
		<method name="addDecoration" returnType="Void" mutating="true">
			<comment>Adds a decoration to the chart.</comment>
			<comment>The decoration will be attached to this chart, until removeDecoration is called or the chart is destroyed.</comment>
			<comment type="see">Attachable</comment>
			<parameter name="decoration" type="Decoration">
				<comment>The decoration to add.</comment>
			</parameter>
		</method>
		<method name="addConstraint" returnType="Void" mutating="true">
			<comment>Adds a constraint to the chart.</comment>
			<comment>The constraint will be attached to this chart, until removeConstraint is called or the chart is destroyed.</comment>
			<comment type="see">Attachable</comment>
			<parameter name="constraint" type="Constraint">
				<comment>The constraint to add.</comment>
			</parameter>
		</method>
		<method name="removeAxis" returnType="Void" mutating="true">
			<comment>Removes a previously added axis.</comment>
			<comment>The axis will also be detached from the chart</comment>
			<comment type="see">Attachable</comment>
			<parameter name="axis" type="Axis">
				<comment>The axis to remove.</comment>
			</parameter>
		</method>
		<method name="removeSeries" returnType="Void" mutating="true">
			<comment>Removes a previously added series.</comment>
			<comment>The series will also be detached from the chart</comment>
			<comment type="see">Attachable</comment>
			<parameter name="series" type="Series">
				<comment>The series to remove.</comment>
			</parameter>
		</method>
		<method name="removeDecoration" returnType="Void" mutating="true">
			<comment>Removes a previously added decoration</comment>
			<comment>The decoration will also be detached from the chart</comment>
			<comment type="see">Attachable</comment>
			<parameter name="decoration" type="Decoration">
				<comment>The decoration to remove.</comment>
			</parameter>
		</method>
		<method name="removeConstraint" returnType="Void" mutating="true">
			<comment>Removes a previously added constraint</comment>
			<comment>The constraint will also be detached from the chart</comment>
			<comment type="see">Attachable</comment>
			<parameter name="constraint" type="Constraint">
				<comment>The constraint to remove.</comment>
			</parameter>
		</method>
		<method name="applyAnimation" returnType="Void" mutating="true">
			<comment>Attaches an animation, it will be automatically unattached when it completes or is cancelled.</comment>
			<comment type="see">Attachable</comment>
			<parameter name="animation" type="Animation">
				<comment>The animation to add.</comment>
			</parameter>
		</method>
		<method name="preUpdate" returnType="Void" mutating="true">
			<comment>Load new data</comment>
			<comment>Calling this method is optional (it will be called by update)</comment>
		</method>
		<method name="update" returnType="Boolean" mutating="true">
			<comment>Synchronize changed properties with internal state</comment>
			<comment>A valid size must be set before calling this method</comment>
		</method>
		<method name="preRender" returnType="Void">
			<comment>Prepare OpenGL context for rendering</comment>
			<comment>Must be called from a thread which has the correct OpenGL context.</comment>
			<comment>Calling this method is optional (it will be called by render)</comment>
		</method>
		<method name="render" returnType="Void">
			<comment>Must be called from a thread which has the correct OpenGL context.</comment>
		</method>
		<method name="renderRegion" returnType="Void">
			<comment>Render a partial region, at a given scale.</comment>
			<comment>Must be called from a thread which has the correct OpenGL context.</comment>
			<parameter name="position" type="Point">
				<comment>Region top left corner</comment>
			</parameter>
			<parameter name="size" type="Size">
				<comment>Region size</comment>
			</parameter>
			<parameter name="scale" type="Number">
				<comment>Scale factor</comment>
			</parameter>
		</method>
		<method name="dispose" returnType="Void" mutating="true">
			<comment>Disposes of graphical memory associated with the chart (this will happen automatically when the chart is deallocated,
				but this method is provided for cases where deallocation is non-deterministic (eg Java).</comment>
			<comment>Must be called from a thread which has the correct OpenGL context.</comment>
		</method>
		<method name="handleTouches" returnType="Void" mutating="true">
			<comment>Handle interactions (touch movement).</comment>
			<comment>The next pan/zoom value are calculated from the position and previous position of all active touches.</comment>
			<parameter name="touches" type="List[Touch]">
				<comment>Input touches.</comment>
			</parameter>
		</method>
	</class>

	<struct name="Touch">
		<comment>Representation of a single touch</comment>
		<field name="position" type="Point" description="current position"/>
		<field name="lastPosition" type="Point" description="previous position"/>
	</struct>

</project>