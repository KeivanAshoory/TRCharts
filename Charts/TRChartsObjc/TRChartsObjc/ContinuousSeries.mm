/*******************************************************************************
 * Copyright 2015 Thomson Reuters
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
/* NOTE: This file is autogenerated, do not edit this file directly.*/

#import <TRChartsObjc/ContinuousSeries.h>
#import <TRChartsObjc/ContinuousAxis.h>
#import <TRChartsObjc/ContinuousDataSource.h>
#import <TRChartsObjc/ColorSource.h>

#import <TRCharts/ContinuousSeries.hpp>
#import <TRCharts/ContinuousAxis.hpp>
#import <TRCharts/ContinuousDataSource.hpp>
#import <TRCharts/ColorSource.hpp>

#import <TRChartsObjc/Support/Marshallers.hh>
#import <TRCodegenSupportObjc/Handle.hh>

@implementation TRContinuousSeries

-(TRContinuousSeries*)init {
	TRChartsObjc::verifyCurrentQueue();
	@throw [NSException exceptionWithName:@"Init" reason:@"Cannot construct TRContinuousSeries directly" userInfo:nil];
}

-(TRContinuousAxis *)abscissaAxis {
	TRChartsObjc::verifyCurrentQueue();
	CodegenSupportObjc::Handle * const handle = static_cast<CodegenSupportObjc::Handle *>([self handle]);
	std::shared_ptr<Charts::IContinuousSeries> obj = handle->getNativeObject<Charts::IContinuousSeries>();
	return TRChartsObjc::getContinuousAxisMarshaller().unmarshall(obj->getAbscissaAxis());
}

-(void)setAbscissaAxis:(TRContinuousAxis *)value {
	TRChartsObjc::verifyCurrentQueue();
	CodegenSupportObjc::Handle * const handle = static_cast<CodegenSupportObjc::Handle *>([self handle]);
	std::shared_ptr<Charts::IContinuousSeries> obj = handle->getNativeObject<Charts::IContinuousSeries>();
	obj->setAbscissaAxis(TRChartsObjc::getContinuousAxisMarshaller().marshall(value));
}

-(id<TRContinuousDataSource>)dataSource {
	TRChartsObjc::verifyCurrentQueue();
	@throw [NSException exceptionWithName:@"Call" reason:@"Cannot call TRContinuousSeries::dataSource directly" userInfo:nil];
}

-(void)setDataSource:(id<TRContinuousDataSource>)value {
	TRChartsObjc::verifyCurrentQueue();
	@throw [NSException exceptionWithName:@"Call" reason:@"Cannot call TRContinuousSeries::setDataSource directly" userInfo:nil];
}

-(id<TRColorSource>)colorSource {
	TRChartsObjc::verifyCurrentQueue();
	CodegenSupportObjc::Handle * const handle = static_cast<CodegenSupportObjc::Handle *>([self handle]);
	std::shared_ptr<Charts::IContinuousSeries> obj = handle->getNativeObject<Charts::IContinuousSeries>();
	return TRChartsObjc::getColorSourceMarshaller().unmarshall(obj->getColorSource());
}

-(void)setColorSource:(id<TRColorSource>)value {
	TRChartsObjc::verifyCurrentQueue();
	CodegenSupportObjc::Handle * const handle = static_cast<CodegenSupportObjc::Handle *>([self handle]);
	std::shared_ptr<Charts::IContinuousSeries> obj = handle->getNativeObject<Charts::IContinuousSeries>();
	obj->setColorSource(TRChartsObjc::getColorSourceMarshaller().marshall(value));
}

-(TRCoordinates *)screenPositionToValue:(TRPoint *)screenPosition {
	TRChartsObjc::verifyCurrentQueue();
	CodegenSupportObjc::Handle * const handle = static_cast<CodegenSupportObjc::Handle *>([self handle]);
	std::shared_ptr<Charts::IContinuousSeries> obj = handle->getNativeObject<Charts::IContinuousSeries>();
	return TRChartsObjc::getCoordinatesMarshaller().unmarshall(obj->screenPositionToValue(TRChartsObjc::getPointMarshaller().marshall(screenPosition)));	
}

-(TRPoint *)valueToScreenPosition:(TRCoordinates *)value {
	TRChartsObjc::verifyCurrentQueue();
	CodegenSupportObjc::Handle * const handle = static_cast<CodegenSupportObjc::Handle *>([self handle]);
	std::shared_ptr<Charts::IContinuousSeries> obj = handle->getNativeObject<Charts::IContinuousSeries>();
	return TRChartsObjc::getPointMarshaller().unmarshall(obj->valueToScreenPosition(TRChartsObjc::getCoordinatesMarshaller().marshall(value)));	
}

-(id)getDatum:(long)index {
	TRChartsObjc::verifyCurrentQueue();
	@throw [NSException exceptionWithName:@"Call" reason:@"Cannot call TRContinuousSeries::getDatum directly" userInfo:nil];
}

-(id)interpolateDatum:(double)abscissa {
	TRChartsObjc::verifyCurrentQueue();
	@throw [NSException exceptionWithName:@"Call" reason:@"Cannot call TRContinuousSeries::interpolateDatum directly" userInfo:nil];
}

-(long)getIndexBeforeAbscissaValue:(double)abscissa includeEqual:(BOOL)includeEqual {
	TRChartsObjc::verifyCurrentQueue();
	CodegenSupportObjc::Handle * const handle = static_cast<CodegenSupportObjc::Handle *>([self handle]);
	std::shared_ptr<Charts::IContinuousSeries> obj = handle->getNativeObject<Charts::IContinuousSeries>();
	return TRChartsObjc::getIntegerMarshaller().unmarshall(obj->getIndexBeforeAbscissaValue(TRChartsObjc::getNumberMarshaller().marshall(abscissa), TRChartsObjc::getBooleanMarshaller().marshall(includeEqual)));	
}

-(long)getIndexAfterAbscissaValue:(double)abscissa includeEqual:(BOOL)includeEqual {
	TRChartsObjc::verifyCurrentQueue();
	CodegenSupportObjc::Handle * const handle = static_cast<CodegenSupportObjc::Handle *>([self handle]);
	std::shared_ptr<Charts::IContinuousSeries> obj = handle->getNativeObject<Charts::IContinuousSeries>();
	return TRChartsObjc::getIntegerMarshaller().unmarshall(obj->getIndexAfterAbscissaValue(TRChartsObjc::getNumberMarshaller().marshall(abscissa), TRChartsObjc::getBooleanMarshaller().marshall(includeEqual)));	
}

-(long)getIndexNearestAbscissaValue:(double)abscissa {
	TRChartsObjc::verifyCurrentQueue();
	CodegenSupportObjc::Handle * const handle = static_cast<CodegenSupportObjc::Handle *>([self handle]);
	std::shared_ptr<Charts::IContinuousSeries> obj = handle->getNativeObject<Charts::IContinuousSeries>();
	return TRChartsObjc::getIntegerMarshaller().unmarshall(obj->getIndexNearestAbscissaValue(TRChartsObjc::getNumberMarshaller().marshall(abscissa)));	
}

-(long)getIndexNearestScreenPosition:(TRPoint *)screenPosition {
	TRChartsObjc::verifyCurrentQueue();
	CodegenSupportObjc::Handle * const handle = static_cast<CodegenSupportObjc::Handle *>([self handle]);
	std::shared_ptr<Charts::IContinuousSeries> obj = handle->getNativeObject<Charts::IContinuousSeries>();
	return TRChartsObjc::getIntegerMarshaller().unmarshall(obj->getIndexNearestScreenPosition(TRChartsObjc::getPointMarshaller().marshall(screenPosition)));	
}

-(double)getDatumSquaredDistanceToScreenPosition:(long)index screenPosition:(TRPoint *)screenPosition {
	TRChartsObjc::verifyCurrentQueue();
	CodegenSupportObjc::Handle * const handle = static_cast<CodegenSupportObjc::Handle *>([self handle]);
	std::shared_ptr<Charts::IContinuousSeries> obj = handle->getNativeObject<Charts::IContinuousSeries>();
	return TRChartsObjc::getNumberMarshaller().unmarshall(obj->getDatumSquaredDistanceToScreenPosition(TRChartsObjc::getIntegerMarshaller().marshall(index), TRChartsObjc::getPointMarshaller().marshall(screenPosition)));	
}

-(TRRange *)getOrdinateRangeWithinAbscissaRange:(TRRange *)abscissaRange {
	TRChartsObjc::verifyCurrentQueue();
	CodegenSupportObjc::Handle * const handle = static_cast<CodegenSupportObjc::Handle *>([self handle]);
	std::shared_ptr<Charts::IContinuousSeries> obj = handle->getNativeObject<Charts::IContinuousSeries>();
	return TRChartsObjc::getRangeMarshaller().unmarshall(obj->getOrdinateRangeWithinAbscissaRange(TRChartsObjc::getRangeMarshaller().marshall(abscissaRange)));	
}

@end